[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Analysis Results Datasets Onboarding",
    "section": "",
    "text": "Overview\nThe CDISC Analysis Results Data (ARD) Model is an emerging standard for encoding statistical analysis outcomes in a machine-readable format. Its primary objective is to streamline the processes of automation, ensuring reproducibility, promoting reusability, and enhancing traceability.\nThe {cards} R package offers a range of functions for ARD generation, from basic univariate summaries like means and tabulations to complex multivariable summaries encompassing regression models and statistical tests.\nThe package includes functionalities to represent results in various formats, including JSON and YAML. Thanks to its flexible structures, the {cards} package can be harnessed in diverse applications, such as generating tables for regulatory submissions and conducting quality control checks on existing tables. Furthermore, the {cards} ARD object can be accessed through a REST API, allowing writers to dynamically incorporate table results into reports.\nThe {cardx} package (extra cards) is a companion to {cards}, exporting more complex functions to generate ARD objects. While {cards} package has minimal dependencies, the {cardx} package will include additional suggested package dependencies.\nWhile {cards} calculates statistics and stores them in a structured object, it cannot present those results; this, however, is where the {gtsummary} package shines. The {gtsummary} package offers a modular framework to construct summary tables. It is the most widely used package for summary tables in the healthcare/pharmaceutical space, and won the American Statistical Association’s 2021 award for Innovation in Statistical Programming and Analytics. The {gtsummary} package is currently being refactored to utilize {cards} as its backend, which will allow users to both extract an ARD object from a {gtsummary} table and use an ARD object to construct a {gtsummary} table. The {cards} and {gtsummary} packages stand as robust and versatile tools, poised to assist in a multitude of analytical endeavors.\n {cards}\n {cardx}\n {gtsummary}\n\n\nPre-work\nBefore we meet to review the details, please complete the following:\n\nReview the full Analysis Results Standard, paying particular attention to the section on Analysis Results Data.\n\nCDISC webinar on the model: https://www.cdisc.org/events/webinar/analysis-results-standard-public-review\n\nReview the {gtsummary} package.\n\nCornell Seminar: https://www.youtube.com/watch?v=tANo9E1SYJE&t=5s\n\nUsing the {cards} package, create a single ARD object that contains all the statistics needed to construct the table below (including the statistics in the header).\n\nUse the cards::ADSL data set.\nUse cards::ard_continuous() and cards::ard_cateogrical() to calculate the statistics.\nUse cards::bind_ard() to combine the results into a single ARD object.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nPlacebo\nN = 86\nXanomeline Low Dose\nN = 84\nXanomeline High Dose\nN = 84\n\n\n\n\nAge\n\n\n\n\n\n\n\n\n    Median (Q1, Q3)\n76 (69, 82)\n78 (71, 82)\n76 (71, 80)\n\n\n    Mean (SD)\n75 (9)\n76 (8)\n74 (8)\n\n\n    Min - Max\n52 - 89\n51 - 88\n56 - 88\n\n\nAge Group, n (%)\n\n\n\n\n\n\n\n\n    &lt;65\n14 (16%)\n8 (9.5%)\n11 (13%)\n\n\n    65-80\n42 (49%)\n47 (56%)\n55 (65%)\n\n\n    &gt;80\n30 (35%)\n29 (35%)\n18 (21%)\n\n\nFemale, n (%)\n53 (62%)\n50 (60%)\n40 (48%)",
    "crumbs": [
      "Home"
    ]
  },
  {
    "objectID": "12-gtsummary-unit-testing.html",
    "href": "12-gtsummary-unit-testing.html",
    "title": "Unit Testing {gtsummary} Tables",
    "section": "",
    "text": "A couple of guidelines while writing unit tests for gtsummary functions.\n\nCreate a test chunk for each argument. If you are testing the interaction of two arguments, make a chunk for that, e.g. test_that(\"tbl_regression(conf.level, conf.int)\").\ntest_that(\"tbl_regression(conf.level)\", {\n  expect_silent(\n    tbl &lt;- lm(age ~ trt + marker, trial) |&gt;\n      tbl_regression(conf.level = 0.80)\n  )\n\n  expect_equal(\n    tbl$table_styling$header |&gt;\n      dplyr::filter(column %in% \"conf.low\") |&gt;\n      dplyr::pull(label),\n    \"**80% CI**\"\n  )\n})\nFor chunks that return messaging or error messaging, create a separate test chunk. Capture error messaging with snapshot tests, so we can assess whether the error’s header appropriately lists the calling function.\ntest_that(\"tbl_uvregression(method.args) messaging\", {\n  # error with an incorrect argument passed\n  expect_snapshot(\n    error = TRUE,\n    tbl_uvregression(\n      trial,\n      y = response,\n      method = glm,\n      method.args = list(not_an_arg = FALSE),\n      include = trt\n    )\n  )\n})\nGenerally, expect_equal() is preferred over snapshot testing. But snapshots are great for error messaging checks.\nWhen using snapshot tests, include one, or perhaps two, tests per test chunk.\nexpect_silent() is a useful tool when creating an object to perform further testing on. Use it when you expect no notes or warnings.\nOur goal is that no matter what a user passes in the arguments (or combination of arguments), they receive a coherent and helpful error message. Keep this in mind while writing unit tests. If inputs result in poor messaging, rather than testing the poor messaging, we should update the function.\nFor arguments that accept functions, check the tidyverse shortcut notation works as well as typical functions, e.g. pvalue_fun = ~style_pvalue(.x)",
    "crumbs": [
      "Unit Testing gtsummary tables"
    ]
  },
  {
    "objectID": "10-gtsummary-objects.html",
    "href": "10-gtsummary-objects.html",
    "title": "{gtsummary} objects",
    "section": "",
    "text": "Every {gtsummary} table has a few characteristics common among all tables created with the package. Here, we review those characteristics, and provide instructions on how to construct a {gtsummary} object.\nThe in-progress version of the package lives in the v2.0 branch.\nLet’s begin by creating two common gtsummary tables: a simple summary and a regression model summary.\n\n# pak::pak(\"ddsjoberg/gtsummary@v2.0\")\nlibrary(gtsummary)\n\ntbl_summary_ex &lt;-\n  trial %&gt;%\n  select(trt, age, grade, response) %&gt;%\n  tbl_summary(by = trt)\n\ntbl_regression_ex &lt;-\n  lm(age ~ grade + marker, trial) %&gt;%\n  tbl_regression() %&gt;%\n  bold_p(t = 0.5)",
    "crumbs": [
      "Inside gtsummary"
    ]
  },
  {
    "objectID": "10-gtsummary-objects.html#inside-gtsummary-objects",
    "href": "10-gtsummary-objects.html#inside-gtsummary-objects",
    "title": "{gtsummary} objects",
    "section": "",
    "text": "Every {gtsummary} table has a few characteristics common among all tables created with the package. Here, we review those characteristics, and provide instructions on how to construct a {gtsummary} object.\nThe in-progress version of the package lives in the v2.0 branch.\nLet’s begin by creating two common gtsummary tables: a simple summary and a regression model summary.\n\n# pak::pak(\"ddsjoberg/gtsummary@v2.0\")\nlibrary(gtsummary)\n\ntbl_summary_ex &lt;-\n  trial %&gt;%\n  select(trt, age, grade, response) %&gt;%\n  tbl_summary(by = trt)\n\ntbl_regression_ex &lt;-\n  lm(age ~ grade + marker, trial) %&gt;%\n  tbl_regression() %&gt;%\n  bold_p(t = 0.5)",
    "crumbs": [
      "Inside gtsummary"
    ]
  },
  {
    "objectID": "10-gtsummary-objects.html#structure-of-a-gtsummary-object",
    "href": "10-gtsummary-objects.html#structure-of-a-gtsummary-object",
    "title": "{gtsummary} objects",
    "section": "Structure of a {gtsummary} object",
    "text": "Structure of a {gtsummary} object\nEvery {gtsummary} object is a list comprising of, at minimum, these elements:\n.$table_body    .$table_styling         \ntable_body is a data frame of the table to be printed, and table_styling are the instructions on how to style the print.\nWe now include an .$cards object internally. This is used to construct .$table_body.\n\ntable_body\nThe .$table_body object is the data frame that will ultimately be printed as the output. The table must include columns \"label\", \"row_type\", and \"variable\". The \"label\" column is printed, and the other two are hidden from the final output.\n\ntbl_summary_ex$table_body\n\n# A tibble: 8 × 7\n  variable var_type    row_type var_label      label          stat_1      stat_2\n  &lt;chr&gt;    &lt;chr&gt;       &lt;chr&gt;    &lt;chr&gt;          &lt;chr&gt;          &lt;chr&gt;       &lt;chr&gt; \n1 age      continuous  label    Age            Age            46 (37, 60) 48 (3…\n2 age      continuous  missing  Age            Unknown        7           4     \n3 grade    categorical label    Grade          Grade          &lt;NA&gt;        &lt;NA&gt;  \n4 grade    categorical level    Grade          I              35 (36%)    33 (3…\n5 grade    categorical level    Grade          II             32 (33%)    36 (3…\n6 grade    categorical level    Grade          III            31 (32%)    33 (3…\n7 response dichotomous label    Tumor Response Tumor Response 28 (29%)    33 (3…\n8 response dichotomous missing  Tumor Response Unknown        3           4     \n\n\n\n\ntable_styling\nThe .$table_styling object is a list of data frames containing information about how .$table_body is printed, formatted, and styled.\nThe list contains the following data frames header, footnote, footnote_abbrev, fmt_fun, indent, text_format, fmt_missing, cols_merge and the following objects source_note, caption, horizontal_line_above.\nheader\nThe header table has the following columns and is one row per column found in .$table_body. The table contains styling information that applies to entire column or the columns headers.\n\n\n\n\n\n\n\n\n\n\n\n\nColumn\nDescription\n\n\n\n\ncolumn\nColumn name from .$table_body\n\n\nhide\nLogical indicating whether the column is hidden in the output. This column is also scoped in modify_header() (and friends) to be used in a selecting environment\n\n\nalign\nSpecifies the alignment/justification of the column, e.g. ‘center’ or ‘left’\n\n\nlabel\nLabel that will be displayed (if column is displayed in output)\n\n\ninterpret_label\nthe {gt} function that is used to interpret the column label, gt::md() or gt::html()\n\n\nspanning_header\nIncludes text printed above columns as spanning headers.\n\n\ninterpret_spanning_header\nthe {gt} function that is used to interpret the column spanning headers, gt::md() or gt::html()\n\n\nmodify_stat_{*}\nany column beginning with modify_stat_ is a statistic available to report in modify_header() (and others)\n\n\n\n\n\n\n\nfootnote & footnote_abbrev\nNOTE: This is a description of the current state. I think this needs some modifications in the near future, e.g. allow more than one footnote per cell, abbreviations should not be footnotes, and be handled more like source notes, etc.\nEach {gtsummary} table may contain a single footnote per header and cell within the table. Footnotes and footnote abbreviations are handled separately. Updates/changes to footnote are appended to the bottom of the tibble. A footnote of NA_character_ deletes an existing footnote.\n\n\n\n\n\n\n\n\n\n\n\n\nColumn\nDescription\n\n\n\n\ncolumn\nColumn name from .$table_body\n\n\nrows\nexpression selecting rows in .$table_body, NA indicates to add footnote to header\n\n\nfootnote\nstring containing footnote to add to column/row\n\n\n\n\n\n\n\nfmt_fun\nNumeric columns/rows are styled with the functions stored in fmt_fun. Updates/changes to styling functions are appended to the bottom of the tibble.\n\n\n\n\n\n\n\n\n\n\n\n\nColumn\nDescription\n\n\n\n\ncolumn\nColumn name from .$table_body\n\n\nrows\nexpression selecting rows in .$table_body\n\n\nfmt_fun\nlist of formatting/styling functions\n\n\n\n\n\n\n\nindent\nInstructions on which columns and rows to indent. Updates/changes to styling functions are appended to the bottom of the tibble.\n\n\n\n\n\n\n\n\n\n\n\n\nColumn\nDescription\n\n\n\n\ncolumn\nColumn name from .$table_body\n\n\nrows\nexpression selecting rows in .$table_body\n\n\nn_spaces\ninteger indeicating teh number of spaces to indent\n\n\n\n\n\n\n\ntext_format\nColumns/rows are styled with bold, italic, or indenting stored in text_format. Updates/changes to styling functions are appended to the bottom of the tibble.\n\n\n\n\n\n\n\n\n\n\n\n\nColumn\nDescription\n\n\n\n\ncolumn\nColumn name from .$table_body\n\n\nrows\nexpression selecting rows in .$table_body\n\n\nformat_type\none of c('bold', 'italic', 'indent')\n\n\nundo_text_format\nlogical indicating where the formatting indicated should be undone/removed.\n\n\n\n\n\n\n\nfmt_missing\nBy default, all NA values are shown blanks. Missing values in columns/rows are replaced with the symbol. For example, reference rows in tbl_regression() are shown with an em-dash. Updates/changes to styling functions are appended to the bottom of the tibble.\n\n\n\n\n\n\n\n\n\n\n\n\nColumn\nDescription\n\n\n\n\ncolumn\nColumn name from .$table_body\n\n\nrows\nexpression selecting rows in .$table_body\n\n\nsymbol\nstring to replace missing values with, e.g. an em-dash\n\n\n\n\n\n\n\ncols_merge\nThis object is experimental and may change in the future. This tibble gives instructions for merging columns into a single column. The implementation in as_gt() will be updated after gt::cols_label() gains a rows= argument.\n\n\n\n\n\n\n\n\n\n\n\n\nColumn\nDescription\n\n\n\n\ncolumn\nColumn name from .$table_body\n\n\nrows\nexpression selecting rows in .$table_body\n\n\npattern\nglue pattern directing how to combine/merge columns. The merged columns will replace the column indicated in ‘column’.\n\n\n\n\n\n\n\nsource_note\nString that is made a table source note. The attribute \"text_interpret\" is either c(\"md\", \"html\").\ncaption\nString that is made into the table caption. The attribute \"text_interpret\" is either c(\"md\", \"html\").\nhorizontal_line_above\nExpression identifying a row where a horizontal line is placed above in the table.\nExample from tbl_regression()\n\ntbl_regression_ex$table_styling\n\n$header\n# A tibble: 23 × 8\n   column             hide  align  interpret_label label  interpret_spanning_h…¹\n   &lt;chr&gt;              &lt;lgl&gt; &lt;chr&gt;  &lt;chr&gt;           &lt;chr&gt;  &lt;chr&gt;                 \n 1 variable           TRUE  center gt::md          varia… gt::md                \n 2 var_label          TRUE  center gt::md          var_l… gt::md                \n 3 var_type           TRUE  center gt::md          var_t… gt::md                \n 4 reference_row      TRUE  center gt::md          refer… gt::md                \n 5 row_type           TRUE  center gt::md          row_t… gt::md                \n 6 header_row         TRUE  center gt::md          heade… gt::md                \n 7 N_obs              TRUE  center gt::md          N_obs  gt::md                \n 8 N                  TRUE  center gt::md          **N**  gt::md                \n 9 coefficients_type  TRUE  center gt::md          coeff… gt::md                \n10 coefficients_label TRUE  center gt::md          coeff… gt::md                \n# ℹ 13 more rows\n# ℹ abbreviated name: ¹​interpret_spanning_header\n# ℹ 2 more variables: spanning_header &lt;chr&gt;, modify_stat_N &lt;int&gt;\n\n$footnote\n# A tibble: 0 × 4\n# ℹ 4 variables: column &lt;chr&gt;, rows &lt;list&gt;, text_interpret &lt;chr&gt;,\n#   footnote &lt;chr&gt;\n\n$footnote_abbrev\n# A tibble: 2 × 4\n  column    rows      text_interpret footnote                \n  &lt;chr&gt;     &lt;list&gt;    &lt;chr&gt;          &lt;chr&gt;                   \n1 conf.low  &lt;quosure&gt; gt::md         CI = Confidence Interval\n2 std.error &lt;quosure&gt; gt::md         SE = Standard Error     \n\n$text_format\n# A tibble: 1 × 4\n  column  rows      format_type undo_text_format\n  &lt;chr&gt;   &lt;list&gt;    &lt;chr&gt;       &lt;lgl&gt;           \n1 p.value &lt;quosure&gt; bold        FALSE           \n\n$indent\n# A tibble: 2 × 3\n  column rows      n_spaces\n  &lt;chr&gt;  &lt;list&gt;       &lt;int&gt;\n1 label  &lt;lgl [1]&gt;        0\n2 label  &lt;quosure&gt;        4\n\n$fmt_missing\n# A tibble: 4 × 3\n  column    rows      symbol\n  &lt;chr&gt;     &lt;list&gt;    &lt;chr&gt; \n1 estimate  &lt;quosure&gt; —     \n2 conf.low  &lt;quosure&gt; —     \n3 std.error &lt;quosure&gt; —     \n4 statistic &lt;quosure&gt; —     \n\n$fmt_fun\n# A tibble: 10 × 3\n   column      rows      fmt_fun\n   &lt;chr&gt;       &lt;list&gt;    &lt;list&gt; \n 1 estimate    &lt;quosure&gt; &lt;fn&gt;   \n 2 N           &lt;quosure&gt; &lt;fn&gt;   \n 3 N_obs       &lt;quosure&gt; &lt;fn&gt;   \n 4 n_obs       &lt;quosure&gt; &lt;fn&gt;   \n 5 conf.low    &lt;quosure&gt; &lt;fn&gt;   \n 6 conf.high   &lt;quosure&gt; &lt;fn&gt;   \n 7 p.value     &lt;quosure&gt; &lt;fn&gt;   \n 8 std.error   &lt;quosure&gt; &lt;fn&gt;   \n 9 statistic   &lt;quosure&gt; &lt;fn&gt;   \n10 var_nlevels &lt;quosure&gt; &lt;fn&gt;   \n\n$cols_merge\n# A tibble: 1 × 3\n  column   rows      pattern                \n  &lt;chr&gt;    &lt;list&gt;    &lt;chr&gt;                  \n1 conf.low &lt;quosure&gt; {conf.low}, {conf.high}",
    "crumbs": [
      "Inside gtsummary"
    ]
  },
  {
    "objectID": "10-gtsummary-objects.html#printing-a-gtsummary-object",
    "href": "10-gtsummary-objects.html#printing-a-gtsummary-object",
    "title": "{gtsummary} objects",
    "section": "Printing a {gtsummary} object",
    "text": "Printing a {gtsummary} object\nAll {gtsummary} objects are printed with print.gtsummary(). Before a {gtsummary} object is printed, it is converted to a {gt} object using as_gt(). This function takes the {gtsummary} object as its input, and uses the information in .$table_styling to construct a list of {gt} calls that will be executed on .$table_body. After the {gtsummary} object is converted to {gt}, it is then printed as any other {gt} object.\nThe package can also utilize other print engines, such as flextable (as_flex_table()), huxtable (as_hux_table()), kableExtra (as_kable_extra()), kable (as_kable()), and tibbles/data frames (as_tibble()/as.data.frame()). The default print engine is set with the theme element \"pkgwide-str:print_engine\"\nWhile the actual print function is slightly more involved, it is basically this:\n\nprint.gtsummary &lt;- function(x) {\n    switch(\n      \"gt\" = as_gt(x),\n      \"flextable\" = as_flex_table(x),\n      \"huxtable\" = as_hux_table(x),\n      \"kable_extra\" = as_kable_extra(x),\n      \"kable\" = as_kable(x)\n    ) |&gt; \n    print()\n}",
    "crumbs": [
      "Inside gtsummary"
    ]
  },
  {
    "objectID": "08-cardx.html",
    "href": "08-cardx.html",
    "title": "{cardx} Overview",
    "section": "",
    "text": "The {cards} package exports many utilities for working with ARD objects. Additionally, {cards} exports utilities for creating new ard_*() functions. The {cardx} package takes advantage of this infrastructure, and exports many other functions for creating more complex ARD objects.\nUtilizing these utilities from {cards}, we can easily create a function to prepare the results from a t-test.\n\ncards::ADSL |&gt; \n  # keep two treatment arms for the t-test calculation\n  dplyr::filter(ARM %in% c(\"Placebo\", \"Xanomeline High Dose\")) |&gt; \n  cardx::ard_stats_t_test(by = ARM, variables = AGE)\n\n{cards} data frame: 14 x 9\n\n\n   group1 variable   context   stat_name stat_label      stat\n1     ARM      AGE stats_t_…    estimate  Mean Dif…     0.828\n2     ARM      AGE stats_t_…   estimate1  Group 1 …    75.209\n3     ARM      AGE stats_t_…   estimate2  Group 2 …    74.381\n4     ARM      AGE stats_t_…   statistic  t Statis…     0.655\n5     ARM      AGE stats_t_…     p.value    p-value     0.513\n6     ARM      AGE stats_t_…   parameter  Degrees …   167.362\n7     ARM      AGE stats_t_…    conf.low  CI Lower…    -1.668\n8     ARM      AGE stats_t_…   conf.high  CI Upper…     3.324\n9     ARM      AGE stats_t_…      method     method Welch Tw…\n10    ARM      AGE stats_t_… alternative  alternat… two.sided\n11    ARM      AGE stats_t_…          mu    H0 Mean         0\n12    ARM      AGE stats_t_…      paired  Paired t…     FALSE\n13    ARM      AGE stats_t_…   var.equal  Equal Va…     FALSE\n14    ARM      AGE stats_t_…  conf.level  CI Confi…      0.95\n\n\nℹ 3 more variables: fmt_fn, warning, error\n\n\nThe utilities allow us to return, not only the results of the t-test, but rows for each of the arguments. This allows us to both report the results, and also in a re-use case, know exactly how the results were calculated, e.g. assuming equal variances, the level of the confidence interval, etc.\nEssentially, every new ard_*() function we write, will be added to {cardx} rather than {cards}.\nFor our ARD work, we will take advantage of the {broom} package and we will use the naming conventions from {broom}. The {broom} package get 500K+ installs every month. With an enormous user base, we can be confident in the results.",
    "crumbs": [
      "cardx Overview"
    ]
  },
  {
    "objectID": "06-helper-functions.html",
    "href": "06-helper-functions.html",
    "title": "Internal Utility Functions",
    "section": "",
    "text": "Internal Utility Functions\nFor non-exported utility functions, there are a few guidelines to follow:\n\nAll function names begin with a period, e.g. .nonexported_utility().\nAny function that does any non-trivial operation must be documented with roxygen comments.\n\n\n\nPull Request Template\n**What changes are proposed in this pull request?**\n* Style this entry in a way that can be copied directly into `NEWS.md`. (#&lt;issue number&gt;, @&lt;username&gt;)\n\nProvide more detail here as needed.\n\n**Reference GitHub issue associated with pull request.** _e.g., 'closes #&lt;issue number&gt;'_\n\n\n--------------------------------------------------------------------------------\n\nPre-review Checklist (if item does not apply, mark is as complete)\n- [ ] **All** GitHub Action workflows pass with a :white_check_mark:\n- [ ] PR branch has pulled the most recent updates from master branch: `usethis::pr_merge_main()`\n- [ ] If a bug was fixed, a unit test was added.\n- [ ] Code coverage is suitable for any new functions/features (generally, 100% coverage for new code): `devtools::test_coverage()`\n- [ ] Request a reviewer\n\nReviewer Checklist (if item does not apply, mark is as complete)\n\n- [ ] If a bug was fixed, a unit test was added.\n- [ ] Run `pkgdown::build_site()`. Check the R console for errors, and review the rendered website.\n- [ ] Code coverage is suitable for any new functions/features: `devtools::test_coverage()`\n\nWhen the branch is ready to be merged:\n- [ ] Update `NEWS.md` with the changes from this pull request under the heading \"`# cards (development version)`\". If there is an issue associated with the pull request, reference it in parentheses at the end update (see `NEWS.md` for examples).\n- [ ] **All** GitHub Action workflows pass with a :white_check_mark:\n- [ ] Approve Pull Request\n- [ ] Merge the PR. Please use \"Squash and merge\" or \"Rebase and merge\".",
    "crumbs": [
      "Helper Functions"
    ]
  },
  {
    "objectID": "04-cards-internals.html",
    "href": "04-cards-internals.html",
    "title": "{cards} Internals",
    "section": "",
    "text": "Utilities for creating ARDs, everything listed under https://insightsengineering.github.io/cards/main/reference/index.html#construct-ards\n\nThe basic cards::ard_*() can also be used to construct bespoke ARDs of different flavors\n\nUtilities for working with ARDs, everything listed under https://insightsengineering.github.io/cards/main/reference/index.html#wrangle-ard",
    "crumbs": [
      "cards for Developers"
    ]
  },
  {
    "objectID": "02-ard-overview.html",
    "href": "02-ard-overview.html",
    "title": "ARD Overview",
    "section": "",
    "text": "We all watched the video…what do you think?",
    "crumbs": [
      "ARD Overview"
    ]
  },
  {
    "objectID": "01-plan.html",
    "href": "01-plan.html",
    "title": "Plan Overview",
    "section": "",
    "text": "We’ll be focusing on {cards}, {cardx}, and {gtsummary}\nThen we can move on to migrating other tern::s_*() functionality into {cardx}",
    "crumbs": [
      "Plan Overview"
    ]
  },
  {
    "objectID": "03-cards-examples.html",
    "href": "03-cards-examples.html",
    "title": "{cards} Overview",
    "section": "",
    "text": "At the heart of the ARS Model lies the Analysis Results Dataset, a standardized format for exchanging and storing analysis results. Imagine it as a neatly organized warehouse where all the crucial information from your clinical trial analysis resides, readily accessible and easy to interpret. The {cards} R package creates ARD from observed data sets, and provides utilities for working with these objects.",
    "crumbs": [
      "cards Overview"
    ]
  },
  {
    "objectID": "03-cards-examples.html#cards",
    "href": "03-cards-examples.html#cards",
    "title": "{cards} Overview",
    "section": "{cards}",
    "text": "{cards}\nThe simplest way to introduce the {cards} R package is with an example of its most basic functionality. In the example below, we are using the ADSL example data set that is included in the package and we are calculating basic summary statistics for continuous variables \"AGE\" and \"BMIBL\".\n\nlibrary(cards)\n\nADSL |&gt; \n  ard_continuous(by = ARM, variables = c(AGE, BMIBL))\n\n{cards} data frame: 48 x 10\n\n\n   group1 group1_level variable stat_name stat_label   stat\n1     ARM      Placebo      AGE         N          N     86\n2     ARM      Placebo      AGE      mean       Mean 75.209\n3     ARM      Placebo      AGE        sd         SD   8.59\n4     ARM      Placebo      AGE    median     Median     76\n5     ARM      Placebo      AGE       p25  25th Per…     69\n6     ARM      Placebo      AGE       p75  75th Per…     82\n7     ARM      Placebo      AGE       min        Min     52\n8     ARM      Placebo      AGE       max        Max     89\n9     ARM      Placebo    BMIBL         N          N     86\n10    ARM      Placebo    BMIBL      mean       Mean 23.636\n\n\nℹ 38 more rows\n\n\nℹ Use `print(n = ...)` to see more rows\n\n\nℹ 4 more variables: context, fmt_fn, warning, error\n\n\nA few items to note from this result:\n\nThe default statistics returned are N, Mean, Standard Deviation, Median, 25th and 75th percentiles, and the minimum and maximum: these can be modified to use any univariate statistic whether that function is user-defined or from another package.\nThese results are calculated by the treatment arm. There is, however, no requirement to include the ard_continuous(by) argument.\nAny unobserved levels of the by= column(s), whether that is unobserved combinations of the by= variables or unobserved factor levels, will appear in the returned ARD table.\nThe results are returned in a structured data frame common among all ard_*() functions.\n\nThere exists similar functionality for categorical data.\n\nard_categorical(ADSL, by = ARM, variables = AGEGR1)\n\n{cards} data frame: 27 x 11\n\n\n   group1 group1_level variable variable_level stat_name stat_label  stat\n1     ARM      Placebo   AGEGR1            &lt;65         n          n    14\n2     ARM      Placebo   AGEGR1            &lt;65         N          N    86\n3     ARM      Placebo   AGEGR1            &lt;65         p          % 0.163\n4     ARM    Xanomeli…   AGEGR1            &lt;65         n          n    11\n5     ARM    Xanomeli…   AGEGR1            &lt;65         N          N    84\n6     ARM    Xanomeli…   AGEGR1            &lt;65         p          % 0.131\n7     ARM    Xanomeli…   AGEGR1            &lt;65         n          n     8\n8     ARM    Xanomeli…   AGEGR1            &lt;65         N          N    84\n9     ARM    Xanomeli…   AGEGR1            &lt;65         p          % 0.095\n10    ARM      Placebo   AGEGR1            &gt;80         n          n    30\n\n\nℹ 17 more rows\n\n\nℹ Use `print(n = ...)` to see more rows\n\n\nℹ 4 more variables: context, fmt_fn, warning, error\n\n\nAs a result of the common structure between this result and the continuous variable summary above, these two data frames can be combined with bind_ard(). The bind_ard() function is similar to dplyr::bind_rows(), and includes a few structural checks found in our ARD data frames, e.g. if we combine two ARDs with duplicate statistics, the function will notify us that the ARD no longer contains unique statistics.\n\nOther Functions\nThe {cards} package also exports functions for tabulating hierarchical data–structures common for adverse event reporting, missing data, and attributes.\n\ncards::ard_hierarchical()\ncards::ard_hierarchical_count()\ncards::ard_missing()\ncards::ard_attributes()\n\nLastly, I wanted to mention the cards::ard_complex() continuous function. This function is similar to ard_continuous() with an important distinction: rather than performing strictly univariate summaries (e.g. mean(x), median(x)), the ard_complex() function uses summary functions that accept x (like ard_continuous() summary functions), the full data frame, and the data frame subset by the by/strata variables.\n\n\nError Messaging\nIt is common that errors or warnings may be return by functions performing these calculations. The {cards} package will continue to return a data frame of the expected structure. Where a statistic that could not be calculate would have appeared, we will now see a NULL value and the error will be captured and returned as text in the \"error\" column.\n\nmean_with_error &lt;- function(x) {\n  stop(\"There was an error calculating the mean.\")\n  mean(x)\n}\n\nard_with_error &lt;-\n  ard_continuous(\n    ADSL, \n    variables = AGE, \n    statistic = ~list(mean = mean_with_error)\n  )\nard_with_error\n\n{cards} data frame: 1 x 8\n\n\n  variable   context stat_name stat_label stat     error\n1      AGE continuo…      mean       Mean      There wa…\n\n\nℹ 2 more variables: fmt_fn, warning\n\n\nThe {cards} package exports many utilities for working with ARDs. The example below is a utility to print any errors or warnings that may have occurred while calculating the statistics.\n\nprint_ard_conditions(ard_with_error)\n\nThe following errors were returned during `print_ard_conditions()`:\n✖ For variable `AGE` and \"mean\" statistic: There was an error calculating the\n  mean.",
    "crumbs": [
      "cards Overview"
    ]
  },
  {
    "objectID": "03-cards-examples.html#list-formula-syntax",
    "href": "03-cards-examples.html#list-formula-syntax",
    "title": "{cards} Overview",
    "section": "List-Formula Syntax",
    "text": "List-Formula Syntax\nMany functions in {cards}, {cardx}, and {gtsummary} have arguments that accept a list-formula syntax, e.g. ard_continuous(statistics). The syntax is explained in detail here: https://insightsengineering.github.io/cards/reference/syntax.html\nBriefly, these arguments accept a few different structures that are processed into a named list using cards::process_formula_selectors(). The two most common are:\n\nNamed List: Named lists are returned as they were passed, unaltered.\nList of Formulas: This may look something like, list(everything() ~ '&lt;value&gt;') or list(AGE ~ 'value', starts_with(\"BM\") ~ 'value'). Everything on the LHS of the formula is processed with {tidyselect} and flattened to a named list.",
    "crumbs": [
      "cards Overview"
    ]
  },
  {
    "objectID": "05-cli-conditions.html",
    "href": "05-cli-conditions.html",
    "title": "Error Messaging",
    "section": "",
    "text": "Slides from Hadley Wickham’s Masterclass for R Package Development\nUnable to display PDF file. Download instead.\nR script for slides\n\nGeneral Structure for Unit Testing\n\nUse small unit testing chunks test_that(\"&lt;descriptive text&gt;\", {...})\nWhile it can be different for various functions, but one chunk per function argument is often sufficient\nBe purposeful when creating snapshot tests. For example, if you’re testing an ARD object correctly captured the error messages, you don’t need to snapshot the entire ARD data frame.\nDo not snapshot printed tibbles or card objects. Each of these has a print method that truncates rows and columns, which will not be captured in a snapshot. Moreover, we don’t want small changes to a print method to break snapshot tests.\nSnapshot tests must be human readable. Note that I DO NOT consider a printed data frame with breaks across the column to be human readable. If needed, break a snapshot test into chunks, e.g. snapshot the first few columns, followed by a snapshot with the remaining columns.\nREVIEW THE SNAPS BEFORE COMMITTING. Not only are you going to inspect the results in the console while writing a snapshot test, you must also review the actual snapshot test. Pay particular attention to these notes from tidyselect, that for now, will only appear in a testing frame work (i.e. when unit tests are run in their own environment, not interactively).\n  Warning:\n  Use of .data in tidyselect expressions was deprecated in tidyselect 1.2.0.\n  i Please use `\"variable_level\"` instead of `.data$variable_level`\nYou can use the options(lifecycle_verbosity = \"error\") option to convert these testing-only messages to errors, which makes them much easier to track down.\nShould each snapshot test live in its own chunk? That will give a proper heading to each of the snapshots, so we know what is being tested by that snapshot.\n\n\n\nTesting Error Messages\nThere are various ways to check appropriate error messaging, and snapshot testing is my favorite. This ensures the exact error you’re planning for is the one returned.\nexpect_snapshot(\n  error = TRUE, \n  &lt;expr&gt;\n)\n\n\nNote about the future\nWe have a somewhat complex messaging situation. {cards} functions are going to be called from {cardx} and {gtsummary}: in these cases, we want the user to be messaged about the function they ran, even if the error is thrown from {cards}.\nIn the near future, we’ll be implementing something like this:\n# set this function at the top of a user-facing function\nset_cli_abort_call &lt;- function(env = rlang::caller_env()) {\n  if (getOption(\"cli_abort_call\") |&gt; is.null()) {\n    options(cli_abort_call = env)\n    withr::defer(expr = options(cli_abort_call = NULL), envir = env)\n  }\n  invisible()\n}\n\n# use this function in `cli_abort(call=get_cli_abort_call())`\nget_cli_abort_call &lt;- function() {\n  getOption(\"cli_abort_call\", default = parent.frame())\n}\n\n# function called by user\nuser_facing_function &lt;- function() {\n  set_cli_abort_call()\n  check_for_errors()\n}\n\n# an internal function OR exported function from another pkg that throws the error\ncheck_for_errors &lt;- function() {\n  cli::cli_abort(c(\"!\" = \"This is an error!\", \"i\" = \"Be better\"), call = get_cli_abort_call())\n}\n\n# this exhibits the user experience\nuser_facing_function()\n#&gt; Error in `user_facing_function()`:\n#&gt; ! This is an error!\n#&gt; ℹ Be better\n\n# check the default still work when no option is set\ncheck_for_errors()\n#&gt; Error in `check_for_errors()`:\n#&gt; ! This is an error!\n#&gt; ℹ Be better",
    "crumbs": [
      "Error Messaging"
    ]
  },
  {
    "objectID": "07-standalone-scripts.html",
    "href": "07-standalone-scripts.html",
    "title": "Standalone Scripts",
    "section": "",
    "text": "The package utilizes a few standalone scripts that are used across a few projects, including {cards}, {cardx}, and {gtsummary}. Some of these scripts make available shims for common tidyverse functions, so you can use the function without depending on the package. The \"checks\" script is a series of functions to check the argument values supplied by users, and provides informative error messages when the values are not valid. Do not make changes to these files directly: rather, update these files in their source location.\n\nimport-standalone-purrr.R: https://github.com/r-lib/rlang/blob/main/R/standalone-purrr.R\nimport-standalone-forcats.R https://github.com/ddsjoberg/standalone/blob/main/R/standalone-forcats.R\nimport-standalone-stringr.R https://github.com/ddsjoberg/standalone/blob/main/R/standalone-stringr.R\nimport-standalone-checks.R https://github.com/ddsjoberg/standalone/blob/main/R/standalone-checks.R\n\nAfter the update has been made, you can copy the file into the repo with\nusethis::use_standalone(\"r-lib/rlang\", file = \"purrr\")\nusethis::use_standalone(\"ddsjoberg/standalone\", file = \"forcats\")\nusethis::use_standalone(\"ddsjoberg/standalone\", file = \"stringr\")\nusethis::use_standalone(\"ddsjoberg/standalone\", file = \"checks\")",
    "crumbs": [
      "Standalone Scripts"
    ]
  },
  {
    "objectID": "09-gtsummary.html",
    "href": "09-gtsummary.html",
    "title": "{gtsummary} Overview",
    "section": "",
    "text": "Background\nThe {gtsummary} package was born from my previous team’s migration to R. I had written utilities in Stata to improve our reporting workflow, and due to the migration, I needed to provide R utilities.\nThe design of {gtsummary} comes from:\n\nMy experience publishing 250+ academic research manuscripts.\nServing as Statistical Editor for European Urology journal (highest-impact journal in the field).\nHaving authored the original reporting guidelines for European Urology. Guidelines that have subsequently adopted by 7 other academic journals.\n\n\nAnyway, I’ve spent a significant amount of time thinking about statistical reporting!\nThe {gtsummary} package has grown in scope immensely since the first internal version written for my team. It is now the most downloaded package for summary tables in the entire R ecosystem with hundreds of thousands of users.\nYears ago, when we first got 200 downloads in one month, I wrote a chron job to report the monthly downloads relative to other packages.\n\nThe implications of being a widely used package is that we must be extremely cautious and thoughtful about any breaking changes!\n\n\nFuture\nThe {cards} package does not present results and this is where the {gtsummary} package shines. The {gtsummary} package offers a modular framework to construct summary tables. The {gtsummary} package is the most widely used package for summary tables in the R ecosystem, and won the American Statistical Association’s 2021 award for Innovation in Statistical Programming and Analytics and it’s currently being refactored with a {cards} backend.\nAfter the update, ARDs will play two important roles in a {gtsummary}.\n\nAn ARD will be a byproduct of every {gtsummary} tables created.\nThe package will also support an ARD-first approach, ingesting the ARD and returning a {gtsummary} table.\n\n\n\n\n\n\n\nARD to Table\nThe graphic below illustrates quite generally the approach we’ll take converting an ARD object created with {cards} to a {gtsummary} table.\n\nbrdg_*(): Bridge functions take the ARD data frame and create the {gtsummary} table. Primarily, this involves creating the underlying .$table_body data frame that is printed as the table.\npier_*(): Piers support bridges, and these functions do the same by supporting bridge functions. For example, a tbl_summary() table generally is comprised of continuous, categorical, and dichotomous summaries. Each of these types has an associated pier_*() function to tidy those results, and these pier_*() functions are called by the tbl_summary() brdg_*() function.\n\nBoth the bridge and pier functions can be generalized to support other reporting needs. For example, brdg_summary() constructs the tbl_summary() output from the ARDs, and this will require only a small amount of generalization to support tbl_svysummary() and more.",
    "crumbs": [
      "gtsummary Overview"
    ]
  },
  {
    "objectID": "11-gtsummary-ARD.html",
    "href": "11-gtsummary-ARD.html",
    "title": "Build {gtsummary} with ARDs",
    "section": "",
    "text": "We will use the tbl_summary() function to illustrate how to build a new gtsummary table.\nImagine we wish to construct the table below: it can be done both by passing a data frame to tbl_summary() or an ARD to card_summary(). These functions share most of their internals.\n\nlibrary(gtsummary)\nlibrary(cards)\n\ntbl_summary(\n  trial, \n  by = trt, \n  include = c(marker, age, grade),\n  type = age ~ \"continuous2\",\n  statistic = all_continuous2() ~ c(\"{mean} ({sd})\", \"{median} ({p25}, {p75})\"),\n  missing = \"no\"\n)\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nDrug A\nN = 981\nDrug B\nN = 1021\n\n\n\n\nMarker Level (ng/mL)\n0.84 (0.23, 1.60)\n0.52 (0.18, 1.21)\n\n\nAge\n\n\n\n\n\n\n    Mean (SD)\n47 (15)\n47 (14)\n\n\n    Median (Q1, Q3)\n46 (37, 60)\n48 (39, 56)\n\n\nGrade\n\n\n\n\n\n\n    I\n35 (36%)\n33 (32%)\n\n\n    II\n32 (33%)\n36 (35%)\n\n\n    III\n31 (32%)\n33 (32%)\n\n\n\n1 Median (Q1, Q3); n (%)\n\n\n\n\n\n\n\n# build the ARD with the {cards} package\nard_for_table &lt;- \n  ard_stack(\n    trial,\n    .by = trt,\n    ard_continuous(variables = c(marker, age)),\n    ard_categorical(variables = grade),\n    .missing = TRUE,                     # we use missing information in gtsummary\n    .attributes = TRUE                   # we also use attirbutes like column labels\n  )\n\n# then convert it to a table with `card_summary()`\nard_for_table |&gt; \n  card_summary(\n    type = age ~ \"continuous2\",\n    statistic = all_continuous2() ~ c(\"{mean} ({sd})\", \"{median} ({p25}, {p75})\"),\n    missing = \"no\"\n  )\n\n\n\n\n\n\n\n\n\n\n\n\nCharacteristic\nDrug A\nN = 981\nDrug B\nN = 1021\n\n\n\n\nMarker Level (ng/mL)\n0.8 (0.2, 1.6)\n0.5 (0.2, 1.2)\n\n\nAge\n\n\n\n\n\n\n    Mean (SD)\n47.0 (14.7)\n47.4 (14.0)\n\n\n    Median (25th Percentile, 75th Percentile)\n46.0 (37.0, 60.0)\n48.0 (39.0, 56.0)\n\n\nGrade\n\n\n\n\n\n\n    I\n35 (35.7%)\n33 (32.4%)\n\n\n    II\n32 (32.7%)\n36 (35.3%)\n\n\n    III\n31 (31.6%)\n33 (32.4%)\n\n\n\n1 Median (25th Percentile, 75th Percentile); n (%)\n\n\n\n\n\n\n\n\n\nBuilding Tables\nThe brdg_*() and pier_*() functions help us build gtsummary tables.\nFor the table above, we have one\n\nbrdg_tbl &lt;- ard_for_table |&gt; \n  brdg_summary(\n    by = \"trt\", \n    variables = c(\"marker\", \"age\", \"grade\"),\n    type = list(marker = \"continuous\", age = \"continuous2\", grade = \"categorical\"),\n    statistic = \n      list(\n        marker = \"{median} ({p25}, {p75})\",\n        age = c(\"{mean} ({sd})\", \"{median} ({p25}, {p75})\"), \n        grade = \"{n} / {N}\"\n      )\n  )\nnames(brdg_tbl)\n\n[1] \"table_body\"    \"table_styling\" \"call_list\"    \n\nbrdg_tbl\n\n\n\n\n\n\n\n\n\n\n\n\nlabel\nstat_1\nstat_2\n\n\n\n\nMarker Level (ng/mL)\n0.8 (0.2, 1.6)\n0.5 (0.2, 1.2)\n\n\nAge\n\n\n\n\n\n\nMean (SD)\n47.0 (14.7)\n47.4 (14.0)\n\n\nMedian (25th Percentile, 75th Percentile)\n46.0 (37.0, 60.0)\n48.0 (39.0, 56.0)\n\n\nGrade\n\n\n\n\n\n\nI\n35 / 98\n33 / 102\n\n\nII\n32 / 98\n36 / 102\n\n\nIII\n31 / 98\n33 / 102\n\n\n\n\n\n\n\nThe pier functions are used by the bridge function.\nFor example gtsummary::pier_summary_continuous() built this portion of the .$table_body.\n\nbrdg_tbl$table_body |&gt; \n  dplyr::filter(variable == \"marker\")\n\n# A tibble: 1 × 7\n  variable var_type   row_type var_label            label          stat_1 stat_2\n  &lt;chr&gt;    &lt;chr&gt;      &lt;chr&gt;    &lt;chr&gt;                &lt;chr&gt;          &lt;chr&gt;  &lt;chr&gt; \n1 marker   continuous label    Marker Level (ng/mL) Marker Level … 0.8 (… 0.5 (…\n\n\ngtsummary::pier_summary_continuous2() built this portion of the .$table_body.\n\nbrdg_tbl$table_body |&gt; \n  dplyr::filter(variable == \"age\")\n\n# A tibble: 3 × 7\n  variable var_type    row_type var_label label                    stat_1 stat_2\n  &lt;chr&gt;    &lt;chr&gt;       &lt;chr&gt;    &lt;chr&gt;     &lt;chr&gt;                    &lt;chr&gt;  &lt;chr&gt; \n1 age      continuous2 label    Age       Age                      &lt;NA&gt;   &lt;NA&gt;  \n2 age      continuous2 level    Age       Mean (SD)                47.0 … 47.4 …\n3 age      continuous2 level    Age       Median (25th Percentile… 46.0 … 48.0 …\n\n\nand gtsummary::pier_summary_categorical() built this section.\n\nbrdg_tbl$table_body |&gt; \n  dplyr::filter(variable == \"grade\")\n\n# A tibble: 4 × 7\n  variable var_type    row_type var_label label stat_1  stat_2  \n  &lt;chr&gt;    &lt;chr&gt;       &lt;chr&gt;    &lt;chr&gt;     &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   \n1 grade    categorical label    Grade     Grade &lt;NA&gt;    &lt;NA&gt;    \n2 grade    categorical level    Grade     I     35 / 98 33 / 102\n3 grade    categorical level    Grade     II    32 / 98 36 / 102\n4 grade    categorical level    Grade     III   31 / 98 33 / 102\n\n\nThese three structures provide the basis for most table structures.",
    "crumbs": [
      "Build gtsummary with ARDs"
    ]
  },
  {
    "objectID": "99-whats-next.html",
    "href": "99-whats-next.html",
    "title": "What’s Next?",
    "section": "",
    "text": "Priorities\n\nGet the {cards} R package in a place to make it’s first release. Focus on the GitHub issues tagged with v0.1.0 in the {cards} repo.\nAdd cardx::ard_*() functions to support the functionality currently available in {gtsummary}. Focus on the GitHub issues tagged with gtsummary in the {cardx} repo.\nFinalize the additional features we wish to include in {gtsummary}, and implement these features in the package.\nMigrate all existing {gtsummary} to the new structure, and make the {gtsummary} v2.0 release.\nAdd cardx::ard_*() functions to calculate the statistics needed in the TLG catalog.\nBuild templates using our workflow for each of the TLGs in our catalog.",
    "crumbs": [
      "What's Next?"
    ]
  }
]